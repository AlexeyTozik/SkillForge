<div>
<h1>CLCK 09: Шардирование в ClickHouse (создание кластера)</h1>
<div>
<h3><strong>Описание:</strong></h3>
<p>Как упоминалось во вступлении, ClickHouse прекрасно масштабируется горизонтально, что дает нам возможность шардировать данные. Это позволяет нам распараллеливать большие запросы на нескольких серверах, используя всю их мощность. Итак, как же работает данная конструкция?</p>
<p>Все очень и очень просто. Представьте себе что у вас есть таблица с данными о переходе на ваш сайт (допустим access_log). В нее мы просто залили все логи из nginx'а. Все запросы по этой таблице работали очень хорошо и быстро, пока она не разрослать до нескольких миллиардов строк за сутки. И теперь мы хотим произвести шардирование - то есть разделить наши данные пополам - первая половина будет лежать на первом сервере, а вторая на втором. При этом мы естественно не хотим вручную делать запрос на каждом сервере, а потом агрегировать эти данные. Все должен делать кликхаус.</p>
<p>Итак, кликхаус позволяет нам это сделать достаточно простым способом. Мы создаем идентичные таблицы на каждой ноде и записываем половину данных на первый сервер, а вторую половину на второй. После этого на каждом сервере создаем distributed таблицу, которая будет опрашивать все наши шарды, забирать данные, агрегировать их и отдавать нам конечный результат. Естественно distributed таблице нужно знать какие ноды входят в наш кластер и какие шарды у нас есть - поэтому нам придется описать наш кластер в конфигурации. Но все остальное за нас сделает кликхаус.</p>
<p>Итак, в данном задании мы создадим кластер из 2-х нод ClickHouse, а для этого нам нужно:</p>
<ol>
<li>Установить ClickHouse на все машины кластера.</li>
<li>Описать структуру кластера в конфигурационном файле.</li>
<li>Создать локальные таблицы на каждой из нод кластера.</li>
<li>Создать <code>distributed</code> таблицы (view) для таблиц кластера.</li>
</ol>
<h4>Установка clickhouse на все машины кластера</h4>
<p>На самом деле здесь нет ничего хитрого - всего лишь надо так же добавить официальные репозитории и запустить команду apt для установки сервера. Единственный момент, который мы хотим посоветовать - это соблюдать одинаковую версию на всех нодах кластера, чтобы не возникало никаких проблем.</p>
<p>При обновлении, так же стоит выделять отдельную ноду для тестирования апгрейда и смотреть как кликхаус общается с ней. Вообще все большие изменения описываются в release notes для каждой конкретной версии кликхауса, поэтому читайте их перед обновлением и проводите тесты на своем внутреннем стенде.</p>
<h4>Конфигурация ClickHouse кластера</h4>
<p>А теперь переходим к конфигурации кластера. Основные параметры в конфигурационном файле <code>config.xml</code>, которые нас интересуют - это:</p>
<ul>
<li><strong>remote_servers -</strong> &mdash; основное место, где описывается структура кластера.</li>
<li><strong>include_from -</strong> &mdash; путь к конфигурационному файлу с подстановками.</li>
</ul>
<pre><code>&lt;remote_servers incl="clickhouse_remote_servers" /&gt;
</code></pre>
<p>Убедитесь, что параметр выше в конфиге пустой. Если нет, то удалите содержимое этих параметров и оставьте так, как указано в примере, поскольку мы вынесем конфигурацию кластера в отдельный файл с подстановками.</p>
<p>В нашем примере есть атрибут <code>incl="some_name"</code>. Он сообщает, что если в файле с подстановками есть параметр, имя которого соответствует значению этого атрибута, то он будут подставлен в соответствующее место. Сконфигурировать путь файла с подстановками можно через параметр <code>&lt;include_from&gt;</code>.</p>
<p>Если этот параметр еще не указан в <code>config.xml</code>, то нам нужно добавить его. Название файла с подстановками может быть произвольное, но я назову его <code>cluster.xml</code>.</p>
<pre><code>&lt;include_from&gt;/etc/clickhouse-server/cluster.xml&lt;/include_from&gt;
</code></pre>
<p>Теперь перейдем к конфигурации самого кластера. Наш кластер состоит из 2-х шардов по 1-й реплике в каждом. Каждая нода ClickHouse является репликой. Для начала мы обойдемся без репликации данных. Полная конфигурация <code>cluster.xml</code> выглядит следующим образом:</p>
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;yandex&gt;
 &lt;clickhouse_remote_servers&gt;
 &lt;mycluster&gt; // Название кластера
 &lt;shard&gt;
 &lt;replica&gt;
 &lt;host&gt;167.99.142.32&lt;/host&gt; // первая нода в нашем кластере
 &lt;port&gt;9000&lt;/port&gt;
 &lt;/replica&gt;
&lt;/shard&gt;
&lt;shard&gt;
 &lt;replica&gt;
 &lt;host&gt;159.65.123.161&lt;/host&gt; // вторая нода в нашем кластере
 &lt;port&gt;9000&lt;/port&gt;
 &lt;/replica&gt;
 &lt;/shard&gt;
 &lt;/mycluster&gt;
 &lt;/clickhouse_remote_servers&gt;
&lt;/yandex&gt;
</code></pre>
<p>В данном параметре <code>remote_servers</code> (<code>clickhouse_remote_servers</code>) мы можем описать любое кол-во кластеров. В нем мы описываем название нашего кластера (<code>mycluster</code>), кол-во шардов и реплик в нём. Поэтому для каждой реплики указываем адрес и порт (TCP) <code>ch1</code> и <code>ch2</code> соответственно.</p>
<p>Эта схема добавляет огромную гибкость - вы можете использовать кликхаус сервер в разных кластерах одновременно. То есть для некоторых таблиц он может являться 3им шардом в тестовом кластере, но при этом для другой таблице он может быть 1-ым шардом в стейджовом кластере.</p>
<h4>Тестирование кластера ClickHouse</h4>
<p>Теперь, когда мы закончили с конфигурацией, нужно проверить, все ли корректно работает. Для начала убедимся, что ClickHouse обнаружил и успешно прочитал наш <code>cluster.xml</code> конфиг-файл.</p>
<p>Перезапустим сервис для применения конфига и посмотрим логи, нас интересует строка <code>Including configuration file '/etc/clickhouse-server/cluster.xml'.</code>. Если в логах есть это сообщение, а в логах ошибок ClickHouse нет замечаний &mdash; идем дальше.</p>
<h4>Создание таблиц в кластере</h4>
<p>Чтобы протестировать работоспособность кластера, создадим на нем таблицы. Они должны находиться на всех нодах и называться одинаково.</p>
<pre><code>CREATE TABLE posts
(
 id Int64,
 title String,
 description String,
 content String,
 date Date
)
ENGINE = MergeTree()
PARTITION BY date
ORDER BY id;
</code></pre>
<p>Здесь стоит отметить формат создания таблицы. Хоть мы и не углубляемся в данные и их хранение, но здесь стоит обратить внимание на ключевое слово ENGINE, которое указывает какой движок для таблицы необходимо использовать. Условно все движки можно разделить на два типа - виртуальные и для хранения данных. Виртуальные - это те, которое фактически не хранят никаких данных, а забирают их из других источников. А вот движки для хранения данных физически хранят данные в файлах на диске и читают их при селект запросах.</p>
<p>Основной движок для хранения данных - mergetree. Он хранит данные и в фоновом режиме производит их сортировку и слияние. При записи данных в таблицу типа merge tree, движок создает файл на диске - part и сохраняет туда полученные данные. Потом в фоновом режиме он берет несколько частей таблицы, сортирует значения по первичному ключу (чаще всего по дате / времени) и объединяет несколько файлов в один.</p>
<p>В процессе слияния и сортировки некоторые движки могут, например, агрегировать ваши данные по какому-то ключу или условию. Один из таких движков называется SummingMergeTree, который суммирует ваши данные.</p>
<h3>Создание Distributed таблиц</h3>
<p>Для начала проясним, что такое distributed таблица в ClickHouse?</p>
<p>Distributed (распределенная) таблица не хранит никаких данных и по сути является виртуальной, как мы выяснили выше. Её основная задача &mdash; распределение запросов на все локальные таблицы в узлах кластера. К примеру при запросе <code>SELECT</code> Distributed таблица переписывает запрос, выбирает нужные удаленные узлы и отправляет им запрос. При этом стоить заметить, что сам запрос максимально обрабатывается на стороне узлов. Как только Distributed таблица получает данные она их объединяет.</p>
<p>Теперь к созданию Distributed таблиц. Они должны иметь такую же структуру, как и таблицы, которые мы создали ранее, но другой движок для запросов:</p>
<pre><code>CREATE TABLE posts_distributed
(
 id Int64,
 title String,
 description String,
 content String,
 date Date
)
ENGINE = Distributed('mycluster', 'default', 'posts', rand());
</code></pre>
<p>В параметрах движка таблицы мы указываем:</p>
<ul>
<li>имя кластера,</li>
<li>база данных с таблицей,</li>
<li>имя таблицы,</li>
<li>ключ шардирования.</li>
</ul>
<h3>Способы вставки данных в кластер</h3>
<p>Теперь пришло время вставки данных в ClickHouse. Мы можем вставлять данные либо в конкретный шард, либо используя distributed таблицу. Для начала вставим данные только в один шард (ноду <code>ch1</code>).</p>
<pre><code>root@ch1:~# clickhouse-client --query "INSERT INTO posts FORMAT CSV" &lt; posts.csv
root@ch1:~# clickhouse-client --query "SELECT count() FROM posts"
500000
</code></pre>
<p>Как мы видим, данные вставились. Теперь сделаем выборку с <code>ch2</code> ноды:</p>
<pre><code>root@ch2:~# clickhouse-client --query "SELECT count() FROM posts"
0
root@ch2:~# clickhouse-client --query "SELECT count() FROM posts_distributed"
500000
</code></pre>
<p>Видно, что на другой ноде данных в табличке <code>posts</code> нету, поскольку мы вставили их прямо в шард. Но они есть в <code>posts_distributed</code>, поскольку эта таблица смотрит на оба шарда.</p>
<p>Отлично, мы успешно реализовали ClickHouse кластер!</p>
<h3><strong>Полезные ссылки:</strong></h3>
<ul>
<li><a href="https://clickhouse.tech/docs/ru/development/architecture/#distributed-query-execution">https://clickhouse.tech/docs/ru/development/architecture/#distributed-query-execution</a></li>
<li><a href="https://clickhouse.tech/docs/ru/engines/table-engines/special/distributed/">https://clickhouse.tech/docs/ru/engines/table-engines/special/distributed/</a></li>
</ul>
</div>
<div>&nbsp;</div>
</div>
